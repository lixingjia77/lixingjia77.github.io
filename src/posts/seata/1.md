# Seata分布式事务模式详解


毕业前在蚂蚁实习的组通常会让实习生和校招生选择一个中间件深入学习一下，并作为答辩的一部分。当时很想选XTS，觉得分布式事务框架很牛逼。但因为选XTS的同学太多了，在老板建议下还是看了mq。好在实习也没那么多工作要做，还是看了很多XTS的分享和源码，也做了很多笔记。但离职时笔记也带不出来，时间长了很多细节都忘了。
分布式事务框架在现在的互联网绝非常用的框架，大多数场景下也绝非好的选择。但依然可以从中看到阿里蚂蚁多年的技术沉淀。开源的seata吸收了淘宝TXC和蚂蚁XTS，希望可以学到老牌大厂半个时代之前的中间件开发者对技术和业务的思考。

对Seata的学习可以分成几个部分吧
1. Seata各模式概述：总结下AT模式、TCC模式、Saga模式和XA模式
2. Seata架构/模块设计
3. AT模式源码走读
4. TCC模式源码走读
5. Saga模式源码走读
6. XA模式源码走读
7. 分布式事务讨论：是否要使用分布式事务中间件，代替方案/更优的实践。

备注：相关代码的走读客户端会参考go的实现，服务端参考java

---

Seata作为分布式事务解决方案，其核心目标是确保分布式环境下多个服务操作的原子性——要么全部成功，要么全部回滚。

在单体应用中，事务的原子性可以通过数据库本地事务来保证。然而在微服务架构中，各个服务拥有独立的数据库，分布式事务的实现变得相当复杂。Seata提供了四种事务模式来应对不同场景的需求。

## AT模式

AT模式是Seata主推的分布式事务模式，其核心原理是通过拦截和改写业务SQL来实现自动化的分布式事务管理。

### 技术原理

以下通过一个具体示例来说明AT模式的工作机制：

假设有如下用户表结构：

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  name VARCHAR(255),
  age INT
);
```

业务代码需要执行一个简单的更新操作：

```sql
UPDATE user SET age = age + 1 WHERE id = 1;
```

在AT模式下，业务代码只需配置Seata的代理数据源，即可无侵入地实现分布式事务。Seata会在底层对SQL进行拦截和改写，具体流程如下：

#### 第一阶段：业务SQL执行与回滚日志生成

1. **前镜像获取**：Seata首先查询业务SQL执行前的数据状态
   ```sql
   SELECT id, name, age FROM user WHERE id = 1 FOR UPDATE;
   -- 查询结果: (1, 'Tom', 30)
   ```

2. **业务SQL执行**：执行原始业务逻辑
   ```sql
   UPDATE user SET age = age + 1 WHERE id = 1;
   -- 数据更新为: (1, 'Tom', 31)
   ```

3. **后镜像获取**：记录业务SQL执行后的数据状态
   ```sql
   SELECT id, name, age FROM user WHERE id = 1;
   -- 查询结果: (1, 'Tom', 31)
   ```

4. **回滚日志存储**：将前后镜像数据存储到UNDO_LOG表中，为可能的回滚操作做准备

5. **全局锁申请**：在本地事务提交前，向TC（Transaction Coordinator）申请全局锁，本例中为user表id=1的行锁

6. **本地事务提交**：获得全局锁后提交本地事务，等待TC的最终决议

#### 第二阶段：提交或回滚

**异步提交场景**：
当所有分支事务都成功时，各个参与者只需异步清理UNDO_LOG即可完成全局事务提交。

**补偿回滚场景**：
当全局事务需要回滚时，利用UNDO_LOG中的前镜像数据生成反向SQL，实现数据补偿回滚。由于全局锁的存在，可以有效避免不同全局事务间对同一行数据的脏读写问题。

### 技术评估

**优势**：
- **业务无侵入**：开发者无需修改业务代码，仅需配置代理数据源
- **自动化程度高**：SQL改写、回滚日志生成、补偿操作均由框架自动完成

**局限性**：
- **本地事务与全局事务的隔离性问题**：一阶段本地事务已提交，但全局事务可能回滚，可能导致其他本地事务读取到最终会被回滚的数据，破坏了传统ACID特性
- **性能开销**：全局锁机制和UNDO_LOG的维护带来额外的性能成本
- **单点依赖**：依赖TC的可用性，在某种程度上削弱了微服务的分布式优势

AT模式在技术实现上确实做到了分布式事务的无侵入解决方案，但其实现代价相对较高。对于高价值业务场景（如支付、交易等），在特定的技术背景下，这种强一致性保证仍然是最稳妥的选择。

## TCC模式

TCC（Try-Confirm-Cancel）模式是一种侵入式的两阶段提交实现方案，要求业务服务实现三个原子接口。

### 核心概念

- **Try阶段**：尝试执行业务，完成所有业务检查，预留必要的业务资源
- **Confirm阶段**：确认执行业务，使用Try阶段预留的业务资源
- **Cancel阶段**：取消执行业务，释放Try阶段预留的业务资源

### 技术优势

1. **真正的分布式架构**：不依赖全局单点服务或数据库，具备更好的性能和可扩展性
2. **业务控制力强**：业务逻辑完全由开发者控制，可以根据具体业务场景进行精细化设计

### 技术挑战

1. **业务侵入性**：需要业务开发人员实现额外的TCC接口，增加开发复杂度
2. **分布式问题处理**：业务层和中间件层都需要解决一系列分布式场景下的技术问题

#### 幂等性处理

**问题背景**：
分布式环境下，网络故障、服务重启等因素可能导致重复请求。幂等性要求同一业务实体的多次操作与单次操作效果一致，不产生额外副作用。

**解决方案**：
Seata在框架层面实现幂等控制，通过维护分布式事务状态机，在二阶段Confirm成功后将事务状态标记为"已提交"。后续重复的Confirm请求可通过状态检查直接返回成功，避免重复执行业务逻辑。

#### 空回滚与悬挂问题

**空回滚问题**：
当业务服务未收到Try请求但收到Cancel请求时，可能引发业务逻辑异常。

**悬挂问题**：
由于网络延迟等因素，Cancel请求可能先于Try请求到达，导致事务状态异常。

**解决方案**：
Seata通过分布式事务状态机来处理这些异常场景：
- **空回滚处理**：在执行Cancel前检查事务状态，若无对应Try记录则直接返回成功
- **悬挂处理**：当Cancel先于Try到达时，将事务状态标记为"悬挂"，后续的Try请求直接返回失败

## Saga模式

Saga模式是一种基于补偿机制实现最终一致性的分布式事务方案，其核心思想是将长事务分解为多个短事务，通过补偿操作来保证数据一致性。

### 执行机制

Saga将分布式事务分解为一系列本地事务，每个本地事务执行完成后立即提交。当某个步骤失败时，按照相反顺序执行补偿操作，撤销已完成的操作。

**示例场景**：
用户下单流程包含：账户扣款(-100) → 库存扣减(-1) → 积分增加(+100) → 订单创建

若订单创建失败，则执行补偿：
积分回退(-100) → 库存恢复(+1) → 账户退款(+100)

### 实现模式

#### 编排式Saga（Orchestration）
采用中心化的事务协调器，根据预定义的工作流程推进或回滚事务。Seata的Saga模式属于此类实现。

**特点**：
- 集中化的流程控制
- 配置化的事务编排
- 更好的可观测性和调试能力

#### 协同式Saga（Choreography）
各个业务服务根据事先约定的协议进行自主协调，无需中心化协调器。

**特点**：
- 真正的去中心化
- 更好的容错能力
- 在实际业务中应用更为广泛（如银行冲正、交易逆向等）

### 适用场景

Saga模式特别适合于对一致性要求相对宽松、可以接受最终一致性的业务场景，如订单处理、工件流程等长业务流程。

## XA模式

XA模式基于X/Open XA标准的分布式事务协议，实现了经典的两阶段提交（2PC）机制。

### 技术原理

XA模式通过事务管理器（Transaction Manager）协调多个资源管理器（Resource Manager），确保分布式事务的ACID特性。以MySQL InnoDB为例，其原生支持XA协议。

### 执行流程

1. **Prepare阶段**：TM向所有参与者发送Prepare请求，各RM执行事务但不提交，进入准备状态
2. **Commit/Rollback阶段**：根据所有参与者的Prepare响应，TM决定提交或回滚事务

### 技术特点

**与AT模式的差异**：
- **锁持有时间**：XA模式在两阶段之间持续持有资源锁直到最终提交/回滚，而AT模式一阶段即提交本地事务
- **隔离性实现层次**：XA在数据库层面实现隔离性控制，AT模式在业务与数据库之间通过全局锁实现隔离
- **性能影响**：XA模式的长时间锁定对系统并发性能影响更大

### 适用场景

XA模式适合对数据一致性要求极高、可以接受性能损耗的场景，特别是传统企业级应用的分布式事务需求。

---

## 总结

Seata提供的四种事务模式各有特点，适用于不同的业务场景：

- **AT模式**：无侵入，适合快速接入分布式事务，但需要权衡性能和一致性
- **TCC模式**：高性能，业务控制力强，适合核心业务场景，但开发复杂度较高
- **Saga模式**：适合长流程业务，支持最终一致性，实现相对简单。但缺少隔离性
- **XA模式**：标准化程度高，强一致性，但性能开销较大

选择合适的模式需要综合考虑业务一致性要求、性能需求、开发复杂度等多个维度。

